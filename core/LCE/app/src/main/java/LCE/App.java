/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package LCE;

import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import org.apache.logging.log4j.*;
import org.apache.logging.log4j.core.config.Configurator;
import org.checkerframework.checker.units.qual.s;

/**
 * App.java is java file to select top candidates that have high LCS scores on BBIC to BIC GumTree Difference of given bug and provided pool
 * 
 * The GumTree diff between BBIC and BIC of the given bug is the output of ChangeCollector
 * Provided pool is in component/LCE
 * You can refer to https://github.com/ISEL-HGU/SPI_Helper to make pool
 */
public class App {
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_BLACK = "\u001B[30m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_GREEN = "\u001B[32m";
    public static final String ANSI_YELLOW = "\u001B[33m";
    public static final String ANSI_BLUE = "\u001B[34m";
    public static final String ANSI_PURPLE = "\u001B[35m";
    public static final String ANSI_CYAN = "\u001B[36m";
    public static final String ANSI_WHITE = "\u001B[37m";

    private boolean poolHasCommitId = true;

    static Logger appLogger = LogManager.getLogger(App.class.getName());

    /**
     * Initializes and runs the application, loading properties from the default or specified file.
     * Exits with a fatal error if properties are not found.
     *
     * @param args Command-line arguments (optional file path for properties).
     */
    public static void main(String[] args) {
        Configurator.setLevel(App.class, Level.TRACE);
        appLogger.info(ANSI_YELLOW + "==========================================================" + ANSI_RESET);
        appLogger.info(ANSI_YELLOW + "[status] App Initiated" + ANSI_RESET);
        App main = new App();
        Properties argv = args.length == 0 ? main.loadProperties() : main.loadProperties(args[0]);
        if (argv == null) {
            appLogger.fatal(ANSI_RED + "[fatal] > Properties file not found" + ANSI_RESET);
            System.exit(1);
        } else {
            appLogger.info(ANSI_YELLOW + "[status] Properties file loaded" + ANSI_RESET);
            appLogger.info(ANSI_YELLOW + "[status] running LCE" + ANSI_RESET);
            main.run(argv);
        }
    }

    /**
     * 1. initiate extractor with properties
     * 2. preprocess the results from extractor before next step
     * 3. variable init using properties
     * 4. setup for git loader to load source from git
     * 5. retreive candidate source codes from each git repositories extracted as similar patch cases up to given limit (default : 10)
     * @param properties
     */
    public void run(Properties properties) {

        String spi_path = properties.getProperty("SPI.dir"); // path for SimilarPatchIdentifier project

        Extractor extractor = new Extractor(properties); // Extractor for extracting candidate source codes

        // initiate extractor with properties
        appLogger.trace(ANSI_BLUE + "[status] > running executor..." + ANSI_RESET);
        extractor.run();
        appLogger.trace(ANSI_GREEN + "[status] > extractor ready" + ANSI_RESET);
        List<String> LCEResult = extractor.extract();

        // Pool Directory and Candidate Directory set
        String pool_dir = properties.getProperty("pool.dir");
        String textSimPool_dir = properties.getProperty("textSimPool.dir");
        String targetDiff_dir = properties.getProperty("target_diff.dir");
        String candidates_dir = properties.getProperty("candidates.dir");
        String textSimOrNot = properties.getProperty("text_sim");

        List<String[]> stringListofCommitFile;

        if (textSimOrNot.equals("false")) {
            stringListofCommitFile = commaSeperatedLineToStringArray(LCEResult);
        } else {
            CosineSimilarity cosineSimilarity = new CosineSimilarity(pool_dir, textSimPool_dir, targetDiff_dir, textSimOrNot, false, Integer.parseInt(properties.getProperty("candidate_number")));

            List<String> textSimResult = cosineSimilarity.run(LCEResult);
    
            appLogger.trace(ANSI_GREEN + "[status] > extraction done" + ANSI_RESET);
    
            // preprocess the results from extractor before next step
            stringListofCommitFile = commaSeperatedLineToStringArray(textSimResult);
        }


        appLogger.trace(ANSI_GREEN + "[status] > preprocess success" + ANSI_RESET);


        GitLoader gitLoader = new GitLoader(); // GitLoader for loading source code from git

        // setup for git loader to load source from git
        gitLoader.set(pool_dir, candidates_dir); // argv

        boolean doClean = properties.getProperty("doClean").equals("true");

        // DEBUG : to clean the output directory and generate
        // gitignore files
        if (doClean) {
            appLogger.trace(ANSI_BLUE + "[status] > cleaning result and candidate directory" + ANSI_RESET);
            gitLoader.cleanCandidateAndResultDir();
            appLogger.trace(ANSI_GREEN + "[status] > cleaning done" + ANSI_RESET);
            appLogger.trace(ANSI_BLUE + "[status] > copying gitignore file to result directory and candidate directory"
                    + ANSI_RESET);
            gitLoader.copy(spi_path + "/core/LCE/gitignore/.gitignore",
                    pool_dir + ".gitignore"); // argv
            gitLoader.copy(spi_path + "/core/LCE/gitignore/.gitignore",
                    candidates_dir + ".gitignore"); // argv
            appLogger.trace(ANSI_GREEN + "[status] > gitignore file copied" + ANSI_RESET);
        }

        appLogger.trace(ANSI_BLUE + "[status] > Initiating gitLoader" + ANSI_RESET);

        // retreive candidate source codes from each git repositories
        int paddingLength = String.valueOf(stringListofCommitFile.size()).length();
        gitLoader.setmaxCandidateNum(paddingLength);
        int counter = 0;
        for (String[] line : stringListofCommitFile) {
            gitLoader.setCounter(counter);

            if (!poolHasCommitId) {
                String d4jName = properties.getProperty("d4j_project_name");
                int d4jNum = Integer.parseInt(properties.getProperty("d4j_project_num"));
                String project = d4jName + "-" + d4jNum;

                String gbrProjectAndId = line[0].substring(line[0].indexOf("checkout/") + "checkout/".length());
                String gbrProject = gbrProjectAndId.substring(0, gbrProjectAndId.indexOf('_'));
                String gbrProjectId = gbrProjectAndId.substring(gbrProjectAndId.indexOf('_') + 1, gbrProjectAndId.indexOf('_', gbrProjectAndId.indexOf('_') + 1));

                if (gbrProject.equals("Math")) {
                    gbrProjectId = gbrProjectAndId.split("_")[2];
                }

                appLogger.trace(ANSI_GREEN + "[candidate metadata] > " + d4jName + " - " + String.valueOf(d4jNum) + ANSI_RESET);
                appLogger.trace(ANSI_GREEN + "[candidate metadata] > " + gbrProject + " - " + gbrProjectId + ANSI_RESET);

                // does not copy to the directory
                if (d4jName.equals(gbrProject) && gbrProjectId.equals(String.valueOf(d4jNum))) {
                    appLogger.trace(ANSI_GREEN + "[candidate metadata] > " + "remove cheating" + ANSI_RESET);
                    
                    counter++;
                    continue;
                }

                String paddedCounter = String.format("%0" + paddingLength + "d", counter);

                gitLoader.copy(line[0], candidates_dir + "/" + project + "_rank-" + paddedCounter + "_old.java"); // buggy file
                gitLoader.copy(line[1], candidates_dir + "/" + project + "_rank-" + paddedCounter + "_new.java"); // fixed file
            } else {
                String git_url = line[4];
                String cid_before = line[0];
                String cid_after = line[1];
                String filepath_before = line[2];
                String filepath_after = line[3];
                String d4jName = properties.getProperty("d4j_project_name");
                int d4jNum = Integer.parseInt(properties.getProperty("d4j_project_num"));

                appLogger.trace(ANSI_GREEN + "[candidate metadata] > filepath after : " + filepath_after
                        + ", git repository url : " + git_url + ", defects4j project : " + d4jName + "-" + properties.getProperty("d4j_project_num") + ANSI_RESET);

                gitLoader.config(git_url, cid_before, cid_after, filepath_before, filepath_after, d4jName, d4jNum);
                gitLoader.logGitCloneStatus();

                try {
                    if (gitLoader.load()) {
                        appLogger.trace(ANSI_GREEN + "[status] > gitLoader load success" + ANSI_RESET);
                    } else {
                        appLogger.fatal(ANSI_RED + "[fatal] > gitLoader load failed" + ANSI_RESET);
                    }
                } catch (Exception e) {
                    appLogger.fatal(ANSI_RED + "[fatal] > Exception :" + e.getMessage() + ANSI_RESET);
                }
            }
            
            counter++;
        }

        appLogger.trace(ANSI_GREEN + "[status] > gitLoader done" + ANSI_RESET);
        appLogger.info(ANSI_YELLOW + "==========================================================" + ANSI_RESET);
        appLogger.info(ANSI_YELLOW + "[status] > App done" + ANSI_RESET);
        
        System.exit(0);
    }

    /**
     * Preprocesses a list of strings by splitting each comma-separated line
     * into an array of five elements. Returns a list of string arrays.
     *
     * @param result The input list of strings to be processed.
     * @return A list of string arrays obtained by splitting each line.
     */
    public List<String[]> commaSeperatedLineToStringArray(List<String> result) {
        List<String[]> result_split = new ArrayList<>();
        try {
            for (String line : result) {
                // System.out.println("[debug] line : " + line);
                String[] line_split = line.split(",");
                String[] selection = null;

                if (line_split.length < 6) {
                    selection = new String[] { line_split[0], line_split[1], line_split[2]}; //BIC_FILE, BFC_FILE, Project_Name
                    poolHasCommitId = false;
                } else if (line_split.length < 8) {
                    selection = new String[] { line_split[0], line_split[1], line_split[2], line_split[3],
                        line_split[4], line_split[5]}; //BBIC, BIC, BBIC_FILE, BIC_FILE, Github_link, Project_Name
                        //example: 567823eb81b7f253662e09a119175b75428abf19,2f9c8ac25ba634affe366ce55eb3f9e969e71ae3,launcher/src/test/java/org/apache/spark/launcher/SparkSubmitCommandBuilderSuite.java,launcher/src/test/java/org/apache/spark/launcher/SparkSubmitCommandBuilderSuite.java,https://github.com/apache/spark,SPARK
                } else {
                    selection = new String[] { line_split[0], line_split[1], line_split[2], line_split[3],
                        line_split[4], line_split[5], line_split[6], line_split[7] }; //BBIC, BIC, BBIC_FILE, BIC_FILE, Github_link, Project_Name
                        //example: 567823eb81b7f253662e09a119175b75428abf19,2f9c8ac25ba634affe366ce55eb3f9e969e71ae3,launcher/src/test/java/org/apache/spark/launcher/SparkSubmitCommandBuilderSuite.java,launcher/src/test/java/org/apache/spark/launcher/SparkSubmitCommandBuilderSuite.java,https://github.com/apache/spark,SPARK,87,87
                }
               
                result_split.add(selection);
            }
        } catch (Exception e) {
            System.out.println("[error] > " + e.getMessage());
        }
        return result_split;
    }

    public Properties loadProperties() {
        return loadProperties("../lce.properties");
    }

    /**
     * Loads properties from the specified file path.
     *
     * This method attempts to load properties from a file located at the given path.
     * It logs the loading process and returns the loaded properties if successful.
     * In case of any exception during the process, it logs a fatal error and returns null.
     *
     * @param path The file path to load properties from.
     * @return A {@code Properties} object that contains the loaded properties, or null if an error occurs.
     */
    public Properties loadProperties(String path) {
        try {
            appLogger.trace(ANSI_BLUE + "[status] > loading properties" + ANSI_RESET);
            File file = new File(path);
            Properties properties = new Properties();
            properties.load(new FileInputStream(file));
            appLogger.trace(ANSI_GREEN + "[status] > properties loaded" + ANSI_RESET);
            return properties;
        } catch (Exception e) {
            appLogger.fatal(ANSI_RED + "[fatal] > Exception : " + e.getMessage() + ANSI_RESET);
            return null;
        }
    }
}
